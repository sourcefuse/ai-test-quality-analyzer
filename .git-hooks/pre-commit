#!/bin/bash

# Pre-commit hook for secret detection
# Prevents committing sensitive data like API keys, tokens, and credentials
#
# This hook checks:
# 1. Staged files for hardcoded secrets
# 2. .env.example for actual credentials (should only have placeholders)
# 3. Common secret patterns (AWS keys, API tokens, private keys, etc.)

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Secret patterns to detect
declare -a SECRET_PATTERNS=(
    # AWS credentials
    "AKIA[0-9A-Z]{16}"                           # AWS Access Key ID
    "aws_secret_access_key.*['\"]?[A-Za-z0-9/+=]{40}['\"]?" # AWS Secret Key

    # API Keys and Tokens - simplified for BSD grep compatibility
    "api.*key.*[A-Za-z0-9_-]{20,}" # Generic API keys
    "api.*token.*[A-Za-z0-9_-]{20,}" # Generic API tokens
    "bearer.*[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+" # JWT tokens

    # Atlassian (JIRA/Confluence) tokens
    "ATATT[A-Za-z0-9_-]"                   # Atlassian API tokens
    "ATCTT[A-Za-z0-9_-]"                   # Atlassian Cloud tokens

    # OpenAI API keys
    "sk-[A-Za-z0-9]"                         # OpenAI API keys (starts with sk-)
    "sk-proj-[A-Za-z0-9_-]"               # OpenAI project keys

    # Anthropic API keys
    "sk-ant-[A-Za-z0-9_-]"                # Anthropic API keys

    # GitHub tokens
    "gh[pousr]_[A-Za-z0-9]"                  # GitHub Personal Access Tokens
    "github_pat_[A-Za-z0-9_]"               # GitHub fine-grained PAT

    # Private keys (simplified patterns for BSD grep compatibility)
    "-----BEGIN.*PRIVATE.*KEY-----"   # RSA/SSH/OpenSSH/PGP private keys

    # Database credentials - simplified for BSD grep
    "postgres://.*:.*@" # PostgreSQL connection strings
    "mysql://.*:.*@"    # MySQL connection strings

    # Generic passwords (in config files) - simplified for BSD grep
    "password.*=.*[A-Za-z0-9]{8,}" # Password assignments

    # OAuth secrets - simplified for BSD grep
    "client_secret.*[A-Za-z0-9_-]{20,}" # OAuth client secrets

    # Slack tokens
    "xox[baprs]-[0-9]+-[0-9]+-[A-Za-z0-9]+" # Slack tokens

    # Docker credentials - simplified for BSD grep
    "dockerhub.*token.*[A-Za-z0-9_-]{20,}"
)

# Files that should never contain actual secrets (only placeholders)
declare -a PLACEHOLDER_FILES=(
    ".env.example"
    ".env.sample"
    ".env.template"
    "env.example"
)

# Placeholder patterns that are acceptable
declare -a PLACEHOLDER_PATTERNS=(
    "your-.*-here"
    "your-.*-token"
    "your-.*-key"
    "example\.com"
    "localhost"
    "127\.0\.0\.1"
    "admin"
    "postgres"
    "placeholder"
    "REPLACE_WITH"
    "TODO:"
    "CHANGEME"
)

echo -e "${BLUE}ğŸ”’ Running pre-commit secret detection...${NC}"

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}âœ… No files staged for commit${NC}"
    exit 0
fi

# Track if any secrets were found
SECRETS_FOUND=0

# Function to check if a value is a placeholder
is_placeholder() {
    local value="$1"

    for pattern in "${PLACEHOLDER_PATTERNS[@]}"; do
        if echo "$value" | grep -qiE "$pattern"; then
            return 0  # Is a placeholder
        fi
    done

    return 1  # Not a placeholder
}

# Function to check a file for secrets
check_file_for_secrets() {
    local file="$1"
    local is_env_example=0

    # Check if this is a placeholder file
    for placeholder_file in "${PLACEHOLDER_FILES[@]}"; do
        if [[ "$file" == *"$placeholder_file"* ]]; then
            is_env_example=1
            break
        fi
    done

    # Get file content
    local content=$(git show ":$file" 2>/dev/null)

    if [ -z "$content" ]; then
        return 0
    fi

    # Check each secret pattern
    for pattern in "${SECRET_PATTERNS[@]}"; do
        local matches=$(echo "$content" | grep -nE "$pattern" | head -5)

        if [ ! -z "$matches" ]; then
            # For .env.example files, check if matches are placeholders
            if [ $is_env_example -eq 1 ]; then
                while IFS=: read -r line_num match; do
                    # Extract the value part (after = sign)
                    local value=$(echo "$match" | sed 's/.*=\s*//')

                    # Check if it's a placeholder
                    if ! is_placeholder "$value"; then
                        echo -e "${RED}âŒ Potential secret found in $file (line $line_num):${NC}"
                        echo -e "${YELLOW}   $match${NC}"
                        SECRETS_FOUND=$((SECRETS_FOUND + 1))
                    fi
                done <<< "$matches"
            else
                # For regular files, report all matches
                while IFS=: read -r line_num match; do
                    echo -e "${RED}âŒ Potential secret found in $file (line $line_num):${NC}"
                    echo -e "${YELLOW}   $match${NC}"
                    SECRETS_FOUND=$((SECRETS_FOUND + 1))
                done <<< "$matches"
            fi
        fi
    done
}

# Check each staged file
while IFS= read -r file; do
    # Skip binary files
    if git diff --cached --numstat "$file" | grep -q "^-"; then
        continue
    fi

    # Skip deleted files
    if [ ! -f "$file" ]; then
        continue
    fi

    check_file_for_secrets "$file"

    # Additional check: GitHub Actions command injection
    if [[ "$file" =~ \.ya?ml$ ]] && [[ "$file" =~ (workflows|\.github) ]]; then
        local workflow_content=$(git show ":$file" 2>/dev/null)

        # Check for dangerous patterns in GitHub Actions workflows
        local dangerous_patterns=(
            'run:.*\$\{\{.*github\.event\.pull_request\.(title|body|head\.ref)'
            'run:.*\$\{\{.*github\.event\.issue\.(title|body)'
            'run:.*\$\{\{.*github\.event\.inputs\.'
            'run:.*\$\{\{.*github\.head_ref'
        )

        for pattern in "${dangerous_patterns[@]}"; do
            if echo "$workflow_content" | grep -qE "$pattern"; then
                echo -e "${RED}âŒ Potential command injection in GitHub Actions workflow: $file${NC}"
                echo -e "${YELLOW}   Pattern: Direct interpolation of untrusted input in 'run:' script${NC}"
                echo -e "${YELLOW}   Fix: Use 'env:' to pass variables safely${NC}"
                echo ""
                echo -e "${BLUE}   Dangerous pattern detected:${NC}"
                echo "$workflow_content" | grep -nE "$pattern" | head -3 | while read -r line; do
                    echo -e "${YELLOW}   $line${NC}"
                done
                echo ""
                echo -e "${GREEN}   Recommended fix:${NC}"
                echo -e "${GREEN}   env:${NC}"
                echo -e "${GREEN}     VAR_NAME: \${{ github.event.pull_request.title }}${NC}"
                echo -e "${GREEN}   run: |${NC}"
                echo -e "${GREEN}     echo \"\$VAR_NAME\"${NC}"
                echo ""
                SECRETS_FOUND=$((SECRETS_FOUND + 1))
            fi
        done
    fi
done <<< "$STAGED_FILES"

# Special check for .env.example - ensure it exists and has no real credentials
if echo "$STAGED_FILES" | grep -q "\.env\.example"; then
    echo -e "${BLUE}ğŸ“‹ Validating .env.example for credential safety...${NC}"

    # Check for common credential formats that shouldn't be in .env.example
    ENV_EXAMPLE_CONTENT=$(git show ":.env.example" 2>/dev/null)

    # Check for actual email addresses (not example.com)
    if echo "$ENV_EXAMPLE_CONTENT" | grep -qE "[a-zA-Z0-9._%+-]+@(?!example\.com|your-domain\.com)[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"; then
        echo -e "${RED}âŒ Real email addresses found in .env.example${NC}"
        echo -e "${YELLOW}   Use placeholder emails like: your-email@example.com${NC}"
        SECRETS_FOUND=$((SECRETS_FOUND + 1))
    fi

    # Check for actual URLs (not localhost or example)
    if echo "$ENV_EXAMPLE_CONTENT" | grep -qE "https?://(?!localhost|127\.0\.0\.1|your-|example\.)[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"; then
        echo -e "${RED}âŒ Real URLs found in .env.example${NC}"
        echo -e "${YELLOW}   Use placeholder URLs like: https://your-instance.example.com${NC}"
        SECRETS_FOUND=$((SECRETS_FOUND + 1))
    fi
fi

# Final result
echo ""
if [ $SECRETS_FOUND -gt 0 ]; then
    echo -e "${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘  âš ï¸  COMMIT BLOCKED - Potential secrets detected!             â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${YELLOW}Found $SECRETS_FOUND potential secret(s) in staged files.${NC}"
    echo ""
    echo -e "${BLUE}Recommendations:${NC}"
    echo "  1. Remove hardcoded secrets from your code"
    echo "  2. Use environment variables instead"
    echo "  3. Ensure .env.example only contains placeholders"
    echo "  4. Add sensitive files to .gitignore"
    echo ""
    echo -e "${BLUE}To bypass this check (not recommended):${NC}"
    echo "  git commit --no-verify"
    echo ""
    exit 1
else
    echo -e "${GREEN}âœ… No secrets detected - commit approved!${NC}"
    exit 0
fi
